import type { ElementNode, SizeValue, BoxNode, ScrollboxNode, TextNode, AsciiFontNode, BorderSide } from "./types"
import { isContainerNode } from "./types"
import { log } from "./logger"
import { ELEMENT_REGISTRY, type SerializableProp } from "../components/elements"

// Serialize a single prop value based on its schema definition
function serializeProp(prop: SerializableProp, value: unknown): string | null {
  if (value === undefined || value === null) return null
  if (value === prop.default) return null

  const { key, type, escape, jsxBoolean, jsxBooleanDefault } = prop

  // Boolean props with jsxBoolean flag
  if (jsxBoolean) {
    if (value === true && jsxBooleanDefault !== true) return key
    if (value === false && jsxBooleanDefault === true) return `${key}={false}`
    if (value === true && jsxBooleanDefault === true) return null // default, skip
    if (value === false && jsxBooleanDefault !== true) return null // default, skip
    return null
  }

  // Options array (select/tab-select)
  if (type === "options") {
    const opts = value as string[]
    if (!opts || opts.length === 0) return null
    const optionsStr = opts.map(o => `{ name: "${o}", value: "${o.toLowerCase().replace(/\s+/g, "_")}" }`).join(", ")
    return `${key}={[${optionsStr}]}`
  }

  // String/color props
  if (type === "string" || type === "color") {
    const strVal = escape ? String(value).replace(/"/g, '\\"') : String(value)
    return `${key}="${strVal}"`
  }

  // Number props
  if (type === "number") {
    return `${key}={${value}}`
  }

  // Boolean props (non-jsxBoolean)
  if (type === "boolean") {
    return value ? `${key}={true}` : `${key}={false}`
  }

  return null
}

// Serialize all props for an element using registry
function serializeRegistryProps(node: ElementNode): string[] {
  const entry = ELEMENT_REGISTRY[node.type]
  if (!entry?.properties) return []

  const result: string[] = []
  for (const prop of entry.properties) {
    const value = (node as unknown as Record<string, unknown>)[prop.key]
    const serialized = serializeProp(prop, value)
    if (serialized) result.push(serialized)
  }
  return result
}

// ============================================================================
// Animation Export - Generates TSX with pre-rendered JSX frames
// ============================================================================

// Generate exportable animation as a TSX module with single default export
// Note: We export children of the root frame, not the root itself (which is the editor canvas)
export function generateAnimationModule(frames: ElementNode[], fps: number, name = "Animation"): string {
  const framesCodes = frames.map((frame, i) => {
    // Export children of root, not root itself (root is the editor canvas with bg/padding)
    const children = frame.children
    if (children.length === 0) {
      return `    // Frame ${i}\n    <></>`
    }
    if (children.length === 1) {
      const frameCode = generateCode(children[0], 2, { stripInternal: true })
      return `    // Frame ${i}\n  ${frameCode}`
    }
    // Multiple children - wrap in fragment
    const childrenCode = children.map(c => generateCode(c, 3, { stripInternal: true })).join(",\n")
    return `    // Frame ${i}\n    <>\n${childrenCode}\n    </>`
  })

  return `/**
 * ${name} - Generated by PlayTUI
 * Frames: ${frames.length} @ ${fps} FPS
 */

export const animation = {
  name: "${name}",
  fps: ${fps},
  frames: [
${framesCodes.join(",\n")}
  ]
}
`
}

function formatSize(val: SizeValue | undefined): string | undefined {
  if (val === undefined) return undefined
  if (typeof val === "number") return String(val)
  return `"${val}"`
}

function formatBorderSides(sides: BorderSide[] | undefined): string | undefined {
  if (!sides || sides.length === 0) return undefined
  return `{[${sides.map(s => `"${s}"`).join(", ")}]}`
}

interface CodegenOptions {
  stripInternal?: boolean  // Remove internal props like name for clean export
}

// Generate code for children only (used for editor preview, hides root wrapper)
export function generateChildrenCode(node: ElementNode, opts: CodegenOptions = {}): string {
  if (node.children.length === 0) return ""
  return node.children.map((c) => generateCode(c, 0, opts)).join("\n")
}

export function generateCode(node: ElementNode, indent = 0, opts: CodegenOptions = {}): string {
  const pad = "  ".repeat(indent)
  const props: string[] = []
  const { stripInternal = false } = opts

  log("CODEGEN", { type: node.type, name: node.name, id: node.id })

  // Name attribute (preserve element names for round-trip editing)
  // Skip for clean export (stripInternal mode)
  if (!stripInternal) {
    const name = node.name || node.type.charAt(0).toUpperCase() + node.type.slice(1)
    props.push(`name="${name}"`)
  }

  if (isContainerNode(node)) {
    // Border properties (container-only)
    if (node.border) {
      if (node.borderSides && node.borderSides.length > 0) {
        props.push(`border={[${node.borderSides.map(s => `"${s}"`).join(", ")}]}`)
      } else {
        props.push("border")
      }
      if (node.borderStyle && node.borderStyle !== "single") {
        props.push(`borderStyle="${node.borderStyle}"`)
      }
      // Only output borderColor if border is enabled
      if (node.borderColor) props.push(`borderColor="${node.borderColor}"`)
      if (node.focusedBorderColor) props.push(`focusedBorderColor="${node.focusedBorderColor}"`)
    }
    if (node.shouldFill === false) props.push("shouldFill={false}")
    if (node.title) props.push(`title="${node.title}"`)
    if (node.titleAlignment && node.titleAlignment !== "left") {
      props.push(`titleAlignment="${node.titleAlignment}"`)
    }
    if (node.backgroundColor) props.push(`backgroundColor="${node.backgroundColor}"`)
    if (node.visible === false) props.push("visible={false}")
  }

  const styleProps: string[] = []

  // Sizing (common to all elements)
  const w = formatSize(node.width)
  const h = formatSize(node.height)
  if (w) styleProps.push(`width: ${w}`)
  if (h) styleProps.push(`height: ${h}`)
  if (node.minWidth) styleProps.push(`minWidth: ${node.minWidth}`)
  if (node.maxWidth) styleProps.push(`maxWidth: ${node.maxWidth}`)
  if (node.minHeight) styleProps.push(`minHeight: ${node.minHeight}`)
  if (node.maxHeight) styleProps.push(`maxHeight: ${node.maxHeight}`)
  if (node.aspectRatio) styleProps.push(`aspectRatio: ${node.aspectRatio}`)

  // Container-only properties (flex, padding, position, overflow)
  if (isContainerNode(node)) {
    const container = node as BoxNode | ScrollboxNode
    
    // Flex container
    if (container.flexDirection) styleProps.push(`flexDirection: "${container.flexDirection}"`)
    if (container.flexWrap) styleProps.push(`flexWrap: "${container.flexWrap}"`)  // OpenTUI uses "no-wrap"
    if (container.justifyContent) styleProps.push(`justifyContent: "${container.justifyContent}"`)
    if (container.alignItems) styleProps.push(`alignItems: "${container.alignItems}"`)
    if (container.alignContent) styleProps.push(`alignContent: "${container.alignContent}"`)
    if (container.gap) styleProps.push(`gap: ${container.gap}`)
    if (container.rowGap) styleProps.push(`rowGap: ${container.rowGap}`)
    if (container.columnGap) styleProps.push(`columnGap: ${container.columnGap}`)

    // Padding
    if (container.padding) styleProps.push(`padding: ${container.padding}`)
    if (container.paddingTop) styleProps.push(`paddingTop: ${container.paddingTop}`)
    if (container.paddingRight) styleProps.push(`paddingRight: ${container.paddingRight}`)
    if (container.paddingBottom) styleProps.push(`paddingBottom: ${container.paddingBottom}`)
    if (container.paddingLeft) styleProps.push(`paddingLeft: ${container.paddingLeft}`)

    // Positioning - our x/y map to OpenTUI's left/top (already handled in common section)
    
    // Overflow
    if (container.overflow) styleProps.push(`overflow: "${container.overflow}"`)
  }

  // Flex item (common to all elements)
  if (node.flexGrow) styleProps.push(`flexGrow: ${node.flexGrow}`)
  if (node.flexShrink !== undefined) styleProps.push(`flexShrink: ${node.flexShrink}`)
  const fb = formatSize(node.flexBasis)
  if (fb) styleProps.push(`flexBasis: ${fb}`)
  if (node.alignSelf && node.alignSelf !== "auto") styleProps.push(`alignSelf: "${node.alignSelf}"`)

  // Positioning (common to all elements via BaseNode)
  if (node.position) styleProps.push(`position: "${node.position}"`)
  if (node.x !== undefined) styleProps.push(`left: ${node.x}`)
  if (node.y !== undefined) styleProps.push(`top: ${node.y}`)
  if (node.zIndex !== undefined) styleProps.push(`zIndex: ${node.zIndex}`)

  // Margin (common to all elements)
  if (node.margin) styleProps.push(`margin: ${node.margin}`)
  if (node.marginTop) styleProps.push(`marginTop: ${node.marginTop}`)
  if (node.marginRight) styleProps.push(`marginRight: ${node.marginRight}`)
  if (node.marginBottom) styleProps.push(`marginBottom: ${node.marginBottom}`)
  if (node.marginLeft) styleProps.push(`marginLeft: ${node.marginLeft}`)

  // Scrollbar options (for scrollbox) - must be added before style prop generation
  if (node.type === "scrollbox") {
    const hasScrollbarOpts = node.showScrollArrows || node.scrollbarForeground || node.scrollbarBackground
    if (hasScrollbarOpts) {
      const scrollbarParts: string[] = []
      if (node.showScrollArrows) scrollbarParts.push("showArrows: true")
      if (node.scrollbarForeground || node.scrollbarBackground) {
        const trackParts: string[] = []
        if (node.scrollbarForeground) trackParts.push(`foregroundColor: "${node.scrollbarForeground}"`)
        if (node.scrollbarBackground) trackParts.push(`backgroundColor: "${node.scrollbarBackground}"`)
        scrollbarParts.push(`trackOptions: { ${trackParts.join(", ")} }`)
      }
      styleProps.push(`scrollbarOptions: { ${scrollbarParts.join(", ")} }`)
    }
  }

  if (styleProps.length > 0) {
    props.push(`style={{ ${styleProps.join(", ")} }}`)
  }

  // Text element - has special content formatting, keep manual
  if (node.type === "text") {
    const textNode = node as TextNode
    const registryProps = serializeRegistryProps(node)
    // Include style props for positioning
    if (styleProps.length > 0) {
      registryProps.push(`style={{ ${styleProps.join(", ")} }}`)
    }
    const content = textNode.content || ""
    
    // Build nested formatting tags
    let formattedContent = content
    if (textNode.bold && textNode.italic) {
      formattedContent = `<strong><em>${content}</em></strong>`
    } else if (textNode.bold) {
      formattedContent = `<strong>${content}</strong>`
    } else if (textNode.italic) {
      formattedContent = `<em>${content}</em>`
    }
    if (textNode.underline) {
      formattedContent = `<u>${formattedContent}</u>`
    }
    if (textNode.strikethrough) {
      formattedContent = `<span strikethrough>${formattedContent}</span>`
    }
    if (textNode.dim) {
      formattedContent = `<span dim>${formattedContent}</span>`
    }
    
    const propsStr = registryProps.length > 0 ? ` ${registryProps.join(" ")}` : ""
    return `${pad}<text${propsStr}>${formattedContent}</text>`
  }

  // Leaf elements - use registry-driven serialization
  if (ELEMENT_REGISTRY[node.type]?.capabilities.supportsChildren === false) {
    const elementProps = serializeRegistryProps(node)
    // Include name for round-trip editing (skip in clean export)
    if (!stripInternal) {
      const name = node.name || ELEMENT_REGISTRY[node.type]?.label || node.type
      elementProps.unshift(`name="${name}"`)
    }
    // Include style props for positioning
    if (styleProps.length > 0) {
      elementProps.push(`style={{ ${styleProps.join(", ")} }}`)
    }
    const propsStr = elementProps.length > 0 ? ` ${elementProps.join(" ")}` : ""
    return `${pad}<${node.type}${propsStr} />`
  }

  // Scrollbox element - container with registry props
  if (node.type === "scrollbox") {
    const scrollboxProps = serializeRegistryProps(node)
    props.push(...scrollboxProps)
    if (node.children.length === 0) {
      return `${pad}<scrollbox ${props.join(" ")} />`
    }
    const childCode = node.children.map((c) => generateCode(c, indent + 1, opts)).join("\n")
    return `${pad}<scrollbox ${props.join(" ")}>\n${childCode}\n${pad}</scrollbox>`
  }

  // Box element (default)
  if (node.children.length === 0) {
    return `${pad}<box ${props.join(" ")} />`
  }

  const childCode = node.children.map((c) => generateCode(c, indent + 1, opts)).join("\n")
  return `${pad}<box ${props.join(" ")}>\n${childCode}\n${pad}</box>`
}
