import type { Renderable, SizeValue, BoxRenderable, ScrollboxRenderable, TextRenderable, AsciiFontRenderable, BorderSide } from "./types"
import { log } from "./logger"
import { RENDERABLE_REGISTRY, isContainerRenderable, type SerializableProp } from "../components/renderables"

// Serialize a single prop value based on its schema definition
function serializeProp(prop: SerializableProp, value: unknown): string | null {
  if (value === undefined || value === null) return null
  if (value === prop.default) return null

  const { key, type, escape, jsxBoolean, jsxBooleanDefault } = prop

  // Boolean props with jsxBoolean flag
  if (jsxBoolean) {
    if (value === true && jsxBooleanDefault !== true) return key
    if (value === false && jsxBooleanDefault === true) return `${key}={false}`
    if (value === true && jsxBooleanDefault === true) return null // default, skip
    if (value === false && jsxBooleanDefault !== true) return null // default, skip
    return null
  }

  // Options array (select/tab-select)
  if (type === "options") {
    const opts = value as string[]
    if (!opts || opts.length === 0) return null
    const optionsStr = opts.map(o => `{ name: "${o}", value: "${o.toLowerCase().replace(/\s+/g, "_")}" }`).join(", ")
    return `${key}={[${optionsStr}]}`
  }

  // String/color props
  if (type === "string" || type === "color") {
    const strVal = escape ? String(value).replace(/"/g, '\\"') : String(value)
    return `${key}="${strVal}"`
  }

  // Number props
  if (type === "number") {
    return `${key}={${value}}`
  }

  // Boolean props (non-jsxBoolean)
  if (type === "boolean") {
    return value ? `${key}={true}` : `${key}={false}`
  }

  return null
}

// Serialize all props for an element using registry
function serializeRegistryProps(node: Renderable): string[] {
  const entry = RENDERABLE_REGISTRY[node.type]
  if (!entry?.properties) return []

  const result: string[] = []
  for (const prop of entry.properties) {
    const value = (node as unknown as Record<string, unknown>)[prop.key]
    const serialized = serializeProp(prop, value)
    if (serialized) result.push(serialized)
  }
  return result
}

// ============================================================================
// Animation Export - Generates TSX with pre-rendered JSX frames
// ============================================================================

// Generate exportable animation as a TSX module with single default export
// Note: We export children of the root frame, not the root itself (which is the editor canvas)
export function generateAnimationModule(frames: Renderable[], fps: number, name = "Animation"): string {
  const framesCodes = frames.map((frame, i) => {
    // Export children of root, not root itself (root is the editor canvas with bg/padding)
    const children = frame.children
    if (children.length === 0) {
      return `    // Frame ${i}\n    <></>`
    }
    if (children.length === 1) {
      const frameCode = generateCode(children[0], 2, { stripInternal: true })
      return `    // Frame ${i}\n  ${frameCode}`
    }
    // Multiple children - wrap in fragment
    const childrenCode = children.map(c => generateCode(c, 3, { stripInternal: true })).join(",\n")
    return `    // Frame ${i}\n    <>\n${childrenCode}\n    </>`
  })

  return `/**
 * ${name} - Generated by PlayTUI
 * Frames: ${frames.length} @ ${fps} FPS
 */

export const animation = {
  name: "${name}",
  fps: ${fps},
  frames: [
${framesCodes.join(",\n")}
  ]
}
`
}

function formatSize(val: SizeValue | undefined): string | undefined {
  if (val === undefined) return undefined
  if (typeof val === "number") return String(val)
  return `"${val}"`
}

function formatBorderSides(sides: BorderSide[] | undefined): string | undefined {
  if (!sides || sides.length === 0) return undefined
  return `{[${sides.map(s => `"${s}"`).join(", ")}]}`
}

interface CodegenOptions {
  stripInternal?: boolean  // Remove internal props like name for clean export
}

// Generate code for children only (used for editor preview, hides root wrapper)
export function generateChildrenCode(node: Renderable, opts: CodegenOptions = {}): string {
  if (node.children.length === 0) return ""
  return node.children.map((c) => generateCode(c, 0, opts)).join("\n")
}

export function generateCode(node: Renderable, indent = 0, opts: CodegenOptions = {}): string {
  const pad = "  ".repeat(indent)
  const props: string[] = []
  const { stripInternal = false } = opts

  log("CODEGEN", { type: node.type, name: node.name, id: node.id })

  // Name attribute (preserve element names for round-trip editing)
  // Skip for clean export (stripInternal mode)
  if (!stripInternal) {
    const name = node.name || node.type.charAt(0).toUpperCase() + node.type.slice(1)
    props.push(`name="${name}"`)
  }

  // Get registry entry
  const entry = RENDERABLE_REGISTRY[node.type]
  if (!entry) return "" // Should not happen

  if (isContainerRenderable(node)) {
    // Border properties (container-only)
    if (node.border) {
      if (node.borderSides && node.borderSides.length > 0) {
        props.push(`border={[${node.borderSides.map(s => `"${s}"`).join(", ")}]}`)
      } else {
        props.push("border")
      }
      if (node.borderStyle && node.borderStyle !== "single") {
        props.push(`borderStyle="${node.borderStyle}"`)
      }
      // Only output borderColor if border is enabled
      if (node.borderColor) props.push(`borderColor="${node.borderColor}"`)
      if (node.focusedBorderColor) props.push(`focusedBorderColor="${node.focusedBorderColor}"`)
    }
    if (node.shouldFill === false) props.push("shouldFill={false}")
    if (node.title) props.push(`title="${node.title}"`)
    if (node.titleAlignment && node.titleAlignment !== "left") {
      props.push(`titleAlignment="${node.titleAlignment}"`)
    }
    // Background color is handled via styleProp for container nodes in registry, 
    // BUT OpenTUI box/scrollbox also support backgroundColor as a direct prop for historical reasons.
    // However, our registry now marks it as a styleProp. 
    // To maintain existing behavior where some props might be direct, we rely on the registry.
    // If a prop is NOT in styleProps, serializeRegistryProps handles it.
    
    if (node.visible === false) props.push("visible={false}")
  }

  const styleProps: string[] = []

  // Iterate over all properties defined in the registry for this element type
  if (entry.properties) {
    for (const prop of entry.properties) {
      const value = (node as unknown as Record<string, unknown>)[prop.key]
      
      // Skip undefined/null or default values
      if (value === undefined || value === null) continue
      if (value === prop.default) continue
      
      // If it's a style prop, format it for the style object
      if (prop.styleProp) {
        let formattedValue: string
        
        if (prop.type === "string" || prop.type === "select" || (prop.type === "color" && typeof value === "string")) {
          formattedValue = `"${value}"`
        } else if (prop.type === "size") {
           const sizeVal = formatSize(value as SizeValue)
           if (!sizeVal) continue
           formattedValue = sizeVal
        } else {
          formattedValue = String(value)
        }

        styleProps.push(`${prop.styleProp}: ${formattedValue}`)
      }
    }
  }

  // Scrollbar options (for scrollbox) - must be added before style prop generation
  if (node.type === "scrollbox") {
    const hasScrollbarOpts = node.showScrollArrows || node.scrollbarForeground || node.scrollbarBackground
    if (hasScrollbarOpts) {
      const scrollbarParts: string[] = []
      if (node.showScrollArrows) scrollbarParts.push("showArrows: true")
      if (node.scrollbarForeground || node.scrollbarBackground) {
        const trackParts: string[] = []
        if (node.scrollbarForeground) trackParts.push(`foregroundColor: "${node.scrollbarForeground}"`)
        if (node.scrollbarBackground) trackParts.push(`backgroundColor: "${node.scrollbarBackground}"`)
        scrollbarParts.push(`trackOptions: { ${trackParts.join(", ")} }`)
      }
      styleProps.push(`scrollbarOptions: { ${scrollbarParts.join(", ")} }`)
    }
  }

  if (styleProps.length > 0) {
    props.push(`style={{ ${styleProps.join(", ")} }}`)
  }

  // Text element - has special content formatting, keep manual
  if (node.type === "text") {
    const textNode = node as TextRenderable
    const registryProps = serializeRegistryProps(node)
    // Include style props for positioning
    if (styleProps.length > 0) {
      registryProps.push(`style={{ ${styleProps.join(", ")} }}`)
    }
    const content = textNode.content || ""
    
    // Build nested formatting tags
    let formattedContent = content
    if (textNode.bold && textNode.italic) {
      formattedContent = `<strong><em>${content}</em></strong>`
    } else if (textNode.bold) {
      formattedContent = `<strong>${content}</strong>`
    } else if (textNode.italic) {
      formattedContent = `<em>${content}</em>`
    }
    if (textNode.underline) {
      formattedContent = `<u>${formattedContent}</u>`
    }
    if (textNode.strikethrough) {
      formattedContent = `<span strikethrough>${formattedContent}</span>`
    }
    if (textNode.dim) {
      formattedContent = `<span dim>${formattedContent}</span>`
    }
    
    const propsStr = registryProps.length > 0 ? ` ${registryProps.join(" ")}` : ""
    return `${pad}<text${propsStr}>${formattedContent}</text>`
  }

  // Leaf elements - use registry-driven serialization
  if (RENDERABLE_REGISTRY[node.type]?.capabilities.supportsChildren === false) {
    const elementProps = serializeRegistryProps(node)
    // Include name for round-trip editing (skip in clean export)
    if (!stripInternal) {
      const name = node.name || RENDERABLE_REGISTRY[node.type]?.label || node.type
      elementProps.unshift(`name="${name}"`)
    }
    // Include style props for positioning
    if (styleProps.length > 0) {
      elementProps.push(`style={{ ${styleProps.join(", ")} }}`)
    }
    const propsStr = elementProps.length > 0 ? ` ${elementProps.join(" ")}` : ""
    return `${pad}<${node.type}${propsStr} />`
  }

  // Scrollbox element - container with registry props
  if (node.type === "scrollbox") {
    const scrollboxProps = serializeRegistryProps(node)
    props.push(...scrollboxProps)
    if (node.children.length === 0) {
      return `${pad}<scrollbox ${props.join(" ")} />`
    }
    const childCode = node.children.map((c) => generateCode(c, indent + 1, opts)).join("\n")
    return `${pad}<scrollbox ${props.join(" ")}>\n${childCode}\n${pad}</scrollbox>`
  }

  // Box element (default)
  if (node.children.length === 0) {
    return `${pad}<box ${props.join(" ")} />`
  }

  const childCode = node.children.map((c) => generateCode(c, indent + 1, opts)).join("\n")
  return `${pad}<box ${props.join(" ")}>\n${childCode}\n${pad}</box>`
}
